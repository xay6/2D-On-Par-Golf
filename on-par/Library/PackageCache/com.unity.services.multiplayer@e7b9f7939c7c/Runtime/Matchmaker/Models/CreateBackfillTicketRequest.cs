//-----------------------------------------------------------------------------
// <auto-generated>
//     This file was generated by the C# SDK Code Generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------------


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine.Scripting;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Unity.Services.Matchmaker.Http;



namespace Unity.Services.Matchmaker.Models
{
    /// <summary>
    /// CreateBackfillTicketRequest model
    /// </summary>
    [Preserve]
    [DataContract(Name = "CreateBackfillTicketRequest")]
    internal class CreateBackfillTicketRequest
    {
        /// <summary>
        /// Creates an instance of CreateBackfillTicketRequest.
        /// </summary>
        /// <param name="connection">The IP address and port of the server creating the backfill (using the format ip:port). This property is used to assign the server to the matching tickets.</param>
        /// <param name="properties">An object that will contain the data representing a Backfill Ticket. The information about the backfill ticket properties is stored in the &#x60;Data&#x60; property of that object. [Backfill Ticket Properties](#tag/backfill_ticket_properties_model) is serialized in base64 (with padding).</param>
        /// <param name="queueName">Tickets are logically grouped together for matchmaking. The tickets must match one of the queue names in the matchmaking config. If not, they will be placed in the default queue.</param>
        /// <param name="attributes">An object that holds a dictionary of attributes (number or string), indexed by the attribute name. The attributes are compared against the corresponding filters defined in the matchmaking config and used to segment the ticket population into pools. The default pool is used if a pool isn&#39;t provided.</param>
        /// <param name="poolId">The ID of the pool to create the backfill ticket in. Cannot be used if the &#x60;attributes&#x60; field is present. The MatchmakingResults in the allocation payload contains the pool ID of the match it was created in. The allocation payload is retrieved by the game server from the payload proxy as described in the [Game Server Hosting Documentation](https://docs.unity.com/game-server-hosting/concepts/allocations-payload.html#Retrieving_the_payload).</param>
        /// <param name="matchId">The ID of the match that this backfill ticket is targeting. The match ID is contained in the MatchmakingResults in the allocation payload. The allocation payload is retrieved by the game server from the payload proxy as described in the [Game Server Hosting Documentation](https://docs.unity.com/game-server-hosting/concepts/allocations-payload.html#Retrieving_the_payload).</param>
        [Preserve]
        public CreateBackfillTicketRequest(string connection, Dictionary<string, byte[]> properties, string queueName = default, Dictionary<string, object> attributes = default, string poolId = default, string matchId = default)
        {
            QueueName = queueName;
            Connection = connection;
            Attributes = (Dictionary<string, IDeserializable>) JsonObject.GetNewJsonObjectResponse(attributes);
            PoolId = poolId;
            Properties = properties;
            MatchId = matchId;
        }

        /// <summary>
        /// Tickets are logically grouped together for matchmaking. The tickets must match one of the queue names in the matchmaking config. If not, they will be placed in the default queue.
        /// </summary>
        [Preserve]
        [DataMember(Name = "queueName", EmitDefaultValue = false)]
        public string QueueName{ get; }

        /// <summary>
        /// The IP address and port of the server creating the backfill (using the format ip:port). This property is used to assign the server to the matching tickets.
        /// </summary>
        [Preserve]
        [DataMember(Name = "connection", IsRequired = true, EmitDefaultValue = true)]
        public string Connection{ get; }

        /// <summary>
        /// An object that holds a dictionary of attributes (number or string), indexed by the attribute name. The attributes are compared against the corresponding filters defined in the matchmaking config and used to segment the ticket population into pools. The default pool is used if a pool isn&#39;t provided.
        /// </summary>
        [Preserve][JsonConverter(typeof(JsonObjectCollectionConverter))]
        [DataMember(Name = "attributes", EmitDefaultValue = false)]
        public Dictionary<string, IDeserializable> Attributes{ get; }

        /// <summary>
        /// The ID of the pool to create the backfill ticket in. Cannot be used if the &#x60;attributes&#x60; field is present. The MatchmakingResults in the allocation payload contains the pool ID of the match it was created in. The allocation payload is retrieved by the game server from the payload proxy as described in the [Game Server Hosting Documentation](https://docs.unity.com/game-server-hosting/concepts/allocations-payload.html#Retrieving_the_payload).
        /// </summary>
        [Preserve]
        [DataMember(Name = "poolId", EmitDefaultValue = false)]
        public string PoolId{ get; }

        /// <summary>
        /// An object that will contain the data representing a Backfill Ticket. The information about the backfill ticket properties is stored in the &#x60;Data&#x60; property of that object. [Backfill Ticket Properties](#tag/backfill_ticket_properties_model) is serialized in base64 (with padding).
        /// </summary>
        [Preserve]
        [DataMember(Name = "properties", IsRequired = true, EmitDefaultValue = true)]
        public Dictionary<string, byte[]> Properties{ get; }

        /// <summary>
        /// The ID of the match that this backfill ticket is targeting. The match ID is contained in the MatchmakingResults in the allocation payload. The allocation payload is retrieved by the game server from the payload proxy as described in the [Game Server Hosting Documentation](https://docs.unity.com/game-server-hosting/concepts/allocations-payload.html#Retrieving_the_payload).
        /// </summary>
        [Preserve]
        [DataMember(Name = "matchId", EmitDefaultValue = false)]
        public string MatchId{ get; }

        /// <summary>
        /// Formats a CreateBackfillTicketRequest into a string of key-value pairs for use as a path parameter.
        /// </summary>
        /// <returns>Returns a string representation of the key-value pairs.</returns>
        internal string SerializeAsPathParam()
        {
            var serializedModel = "";

            if (QueueName != null)
            {
                serializedModel += "queueName," + QueueName + ",";
            }
            if (Connection != null)
            {
                serializedModel += "connection," + Connection + ",";
            }
            if (Attributes != null)
            {
                serializedModel += "attributes," + Attributes.ToString() + ",";
            }
            if (PoolId != null)
            {
                serializedModel += "poolId," + PoolId + ",";
            }
            if (Properties != null)
            {
                serializedModel += "properties," + Properties.ToString() + ",";
            }
            if (MatchId != null)
            {
                serializedModel += "matchId," + MatchId;
            }
            return serializedModel;
        }

        /// <summary>
        /// Returns a CreateBackfillTicketRequest as a dictionary of key-value pairs for use as a query parameter.
        /// </summary>
        /// <returns>Returns a dictionary of string key-value pairs.</returns>
        internal Dictionary<string, string> GetAsQueryParam()
        {
            var dictionary = new Dictionary<string, string>();

            if (QueueName != null)
            {
                var queueNameStringValue = QueueName.ToString();
                dictionary.Add("queueName", queueNameStringValue);
            }

            if (Connection != null)
            {
                var connectionStringValue = Connection.ToString();
                dictionary.Add("connection", connectionStringValue);
            }

            if (Attributes != null)
            {
                var attributesStringValue = Attributes.ToString();
                dictionary.Add("attributes", attributesStringValue);
            }

            if (PoolId != null)
            {
                var poolIdStringValue = PoolId.ToString();
                dictionary.Add("poolId", poolIdStringValue);
            }

            if (Properties != null)
            {
                var propertiesStringValue = Properties.ToString();
                dictionary.Add("properties", propertiesStringValue);
            }

            if (MatchId != null)
            {
                var matchIdStringValue = MatchId.ToString();
                dictionary.Add("matchId", matchIdStringValue);
            }

            return dictionary;
        }
    }
}
